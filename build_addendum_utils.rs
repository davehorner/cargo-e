use regex::Regex;
use std::fs::{self, create_dir_all};
use std::io::{self, Read, Write};
use std::path::Path;
use walkdir::WalkDir;

/// Transforms the contents of a file by:
/// - Removing inner doc comments (lines starting with `//!`),
/// - Removing module declarations (lines that match a simple pattern for `mod` or `pub mod`).
fn transform_file_contents(contents: &str) -> String {
    let mut result = String::new();

    // Regex to match lines that are module declarations.
    // This is a simple pattern; adjust if your code needs more sophistication.
    let mod_decl_re = Regex::new(r"^\s*(pub\s+)?mod\s+\w+\s*;").unwrap();

    for line in contents.lines() {
        let trimmed = line.trim_start();
        // Skip inner doc comments.
        if trimmed.starts_with("//!") {
            continue;
        }
        // Skip module declarations.
        if mod_decl_re.is_match(trimmed) {
            continue;
        }
        result.push_str(line);
        result.push('\n');
    }

    result
}

/// Recursively scans the provided source directory for all `.rs` files,
/// transforms their contents, writes each transformed file into `out_dir`,
/// and returns a String containing Rust module declarations that inline these transformed files.
///
/// Files named "main.rs" are skipped.
pub fn generate_module_includes(src_dir: &Path, out_dir: &Path) -> io::Result<String> {
    let mut output = String::new();
    output.push_str("// Automatically generated by build.rs\n\n");
    println!("SOURCE: {:?}", src_dir);

    // Ensure the output directory exists.
    create_dir_all(out_dir)?;

    // Walk the source directory recursively.
    for entry in WalkDir::new(src_dir).into_iter().filter_map(|e| e.ok()) {
        let path = entry.path();

        // Skip the root directory itself.
        if path == src_dir {
            continue;
        }

        // Skip directories; we want only files.
        if path.is_dir() {
            continue;
        }

        // Process only files with a `.rs` extension.
        if path.is_file() && path.extension().map(|ext| ext == "rs").unwrap_or(false) {
            // Skip files named "main.rs" so we don't inline multiple main functions.
            if let Some(fname) = path.file_name().and_then(|s| s.to_str()) {
                if fname == "main.rs" {
                    println!("Skipping main file: {:?}", path);
                    continue;
                }
            }

            // Compute the relative path from src_dir.
            let rel_path = path.strip_prefix(src_dir).unwrap();
            // Generate a module name by joining the relative path components with underscores and removing the extension.
            let module_name = rel_path
                .with_extension("")
                .iter()
                .filter_map(|s| s.to_str())
                .collect::<Vec<_>>()
                .join("_");
            // (Optional) You can compute a normalized relative path string if needed.
            // let _rel_path_str = rel_path.to_str().unwrap().replace("\\", "/");

            // Read the file contents.
            let mut file_content = String::new();
            std::fs::File::open(path)?.read_to_string(&mut file_content)?;

            // Transform the file content.
            let transformed = transform_file_contents(&file_content);

            // Write the transformed content to a new file in out_dir.
            let out_file_path = out_dir.join(format!("transformed_{}.rs", module_name));
            fs::write(&out_file_path, &transformed)?;

            // Generate the module declaration to inline the transformed file.
            let module_declaration = format!(
                "pub mod {} {{\n    include!(concat!(env!(\"OUT_DIR\"), \"/transformed_{}.rs\"));\n}}\n\n",
                module_name, module_name
            );
            output.push_str(&module_declaration);
            println!("Processed file: {:?} as module '{}'", path, module_name);
        }
    }
    Ok(output)
}

/// Writes the generated content into the destination file.
pub fn write_generated_file(dest_path: &Path, content: &str) -> io::Result<()> {
    if let Some(parent) = dest_path.parent() {
        create_dir_all(parent)?;
    }
    let mut file = std::fs::File::create(dest_path)?;
    file.write_all(content.as_bytes())?;
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;
    use tempfile::tempdir;

    #[test]
    fn test_transform_file_contents() {
        let input = "//! Doc comment\npub mod something;\nfn main() { println!(\"Hello\"); }";
        let transformed = transform_file_contents(input);
        // Ensure that inner doc comments and module declarations are removed.
        assert!(!transformed.contains("//!"));
        assert!(!transformed.contains("pub mod something;"));
        // The rest of the code should remain.
        assert!(transformed.contains("fn main() { println!(\"Hello\"); }"));
    }

    #[test]
    fn test_generate_module_includes_empty_dir() {
        let dir = tempdir().unwrap();
        let src_dir = dir.path();
        let out_dir = dir.path().join("out");
        let result = generate_module_includes(src_dir, &out_dir).unwrap();
        // Should contain the header comment.
        assert!(result.contains("Automatically generated by build.rs"));
        // No module declarations if no .rs files exist.
        assert!(!result.contains("pub mod"));
    }

    #[test]
    fn test_write_generated_file() {
        let dir = tempdir().unwrap();
        let dest_path = dir.path().join("output.rs");
        let content = "pub mod test {}";
        write_generated_file(&dest_path, content).unwrap();
        let written = fs::read_to_string(&dest_path).unwrap();
        assert_eq!(written, content);
    }
}
